<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Widget Annotation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.20.1/cdn/themes/light.css" />
    <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.20.1/cdn/shoelace-autoloader.js"></script>
    <style>

        /* Index level 1 */
        .label-on-left {
            margin-left: 3rem;
            --label-width: 12rem;
            --gap-width: 2rem;
        }

        .label-on-left + .label-on-left {
            margin-top: var(--sl-spacing-medium);
        }

        .label-on-left::part(form-control) {
            display: grid;
            grid: auto / var(--label-width) 1fr;
            gap: var(--sl-spacing-3x-small) var(--gap-width);
            align-items: center;
        }

        .label-on-left::part(form-control-input) {
            justify-self: end; 
            width: 100px;
        }

        .label-on-left::part(form-control-label) {
            text-align: right;
            flex: 1;
            width: 10rem;
        }

        .label-on-left::part(form-control-help-text) {
            grid-column-start: 2;
        }


        .label-on-left-upper {
            margin-top: 2rem;
            margin-bottom: 2rem;
            --label-width: 12rem;
            --gap-width: 2rem;
        }

        .label-on-left-upper + .label-on-left-upper {
            margin-top: var(--sl-spacing-medium);
        }

        .label-on-left-upper::part(form-control) {
            display: grid;
            grid: auto / var(--label-width) 1fr;
            gap: var(--sl-spacing-3x-small) var(--gap-width);
            align-items: center;
        }

        .label-on-left-upper::part(form-control-input) {
            justify-self: end; 
            width: 100px;
            background: #E3F2FF;
        }

        .label-on-left-upper::part(form-control-label) {
            text-align: left;
            flex: 1;
            width: 12rem;
            font-weight: var(--sl-font-weight-semibold);
        }

        .label-on-left-upper::part(form-control-help-text) {
            grid-column-start: 2;
        }

        hr.dashed {
        border-top: 2px dashed #bbb;
        }


        /* Clear floats after the columns */
        .container {
            display: flex; /* Use Flexbox for layout */
            gap: 20px; /* Adds 20px space between columns */
            padding-left: 20px;
            padding-right: 20px;
            justify-content: center; /* Center the columns horizontally */
        }

        .column:first-child {
            flex: 0 0 60%; /* Left column takes 70% of the container */
            max-width: 60%; /* Prevent it from growing larger than 70% */
        }

        .column:last-child {
            flex: 0 0 40%; /* Right column takes 30% of the container */
            max-width: 40%; /* Prevent it from growing larger than 30% */
        }

        .column img {
            max-width: 100%;
            height: auto; /* Ensure the image scales properly */
        }

        sl-button.primary::part(base) {
            background-color: #d7e9ff;
        }

        h1 {
            font-size: var(--sl-font-size-x-large);
            font-family: var(--sl-font-sans);
            font-weight: var(--sl-font-weight-bold);
            line-height: var(--sl-line-height-normal);
        }
        body {
            font-family: var(--sl-font-sans);
            font-size: var(--sl-font-size-medium);
        }

        sl-dropdown::part(panel) {
            width: 30em;
            background-color: var(--sl-panel-background-color, white); 
            border-radius: var(--sl-border-radius-medium);
            box-shadow: var(--sl-shadow-large);
        }

        .transition_button{
            width: 130px;
        }

        .level0{
            display: flex;
            align-items: center; 
            gap: 1rem;
        }

        .level1{
            font-size: var(--sl-font-size-medium);
            width: 500px;
        }

        .level2{
            display: inline-flex;
            width: 100%;
            font-size: var(--sl-font-size-medium);
            font-weight: var(--sl-font-weight-semibold);
        }

        .level2-first-flex-child{
            flex: 1
        }

        .number-style-level0{
            display: flex;
            align-items: center;
            justify-content: center; 
            background: #f9f8a7;
            border-radius: 50%;
            height: 30px;
            width: 30px;
        }

        .number-style-level1{
            display: flex;
            align-items: center;
            justify-content: center; 
            background: #E3F2FF;
            border-radius: 50%;
            height: 30px;
            width: 30px;
        }

        .reasoning-title{
            font-size: var(--sl-font-size-large);
        }

        .smaller-text{
            font-size: 0.875rem;
        }



    </style>
</head>

<body>
    <div class="container">
        <div class="column">
            <div id="video-scenes">
                <!-- Screenshots will be dynamically inserted here -->
            </div>
            <div id="llm-reasoning">
                <p class="reasoning-title"> Widget Description</p>
                <p class ="smaller-text" id="widget-content"></p>
                <!-- Prompt widget description will be dynamically inserted here -->
                <p class="reasoning-title"> Placement and Reasoning</p>
                <p class ="smaller-text" id="reasoning-context" style="white-space: pre-wrap;"></p>
                <!-- Reasoning text will be dynamically inserted here -->
            </div>
        </div>
        <div class="column">
            <h1>Deceptive Design Category Selection</h1>
            <sl-button variant="default" size="small" a href="https://drive.google.com/file/d/12K7xDdavPqzHip-8qBNFckEUqNAqw70v/view?usp=drive_link">
                <sl-icon slot="prefix" name="arrow-up-right-square"></sl-icon>
                View Taxonomoy
            </sl-button>
            <br/>

            <sl-divider></sl-divider>
            <div id="container">
                <p>Do following categories apply? Click the checkbox if you think it applies.</p>
            </div>
            
            <sl-divider></sl-divider>
            <sl-button variant="default" id="prev-button" class="transition_button">
                <sl-icon slot="prefix" name="arrow-left"></sl-icon>
                Previous
            </sl-button>
            <sl-button variant="default" id="next-button" class="transition_button">
                <sl-icon slot="suffix" name="arrow-right"></sl-icon>
                Next
            </sl-button>

    <script>
        // Append category to the question
        const user = getQueryParameter('user');
        const container = document.getElementById("container");
        let current_categories = []; 
        let select_categories = [];
        let index_list = []; // declare globally
        let load_index = 0;

        async function init() {
            const data = await (await fetch('annotator_widget_categories.json')).json();
            index_list = data[user] ?? data.user;           // whichever matches your JSON
            load_index = 0; // always start at the beginning
            await render();
        }

        async function render() {
            const [widgetIndex, categories] = index_list[load_index];
            current_categories = categories;
            displayCategories(categories);

            const videoData = await fetchVideoData();
            const scene = await createVideoScene(videoData[widgetIndex]);
            const videoScenes = document.getElementById('video-scenes');
            videoScenes.innerHTML = `<p>Current widget index: ${widgetIndex}</p>`;
            videoScenes.appendChild(scene);
            }


        function displayCategories(categories){
             // remove previous dynamic rows (keep the intro <p>)
            container.querySelectorAll('.dynamic').forEach(n => n.remove());

            categories.forEach((value, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = 'dynamic';

            // Create checkbox
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = `category-${index}`; // unique ID

            const mapping_category = findMapping(value);

            // Create label linked to checkbox
            const label = document.createElement("label");
            label.setAttribute("for", checkbox.id);
            label.textContent = mapping_category;

            // Add checkbox and label to wrapper
            wrapper.appendChild(checkbox);
            wrapper.appendChild(label);

            // Add wrapper to container
            container.appendChild(wrapper);
            });
        }
        
        async function findMapping(category) {
            const data = await (await fetch('category_mapping.json')).json();
            mapping_category = data[category]["name"];
            return mapping_category;
        }


        // Example: get selected values
        function getSelectedCategories() {
            select_categories = []; // reset each time
            current_categories.forEach((value, index) => {
                if (document.getElementById(`category-${index}`).checked) {
                    select_categories.push(value);
                }
            });
            console.log("User selected:", select_categories);
            return select_categories;
        }


        async function fetchVideoData() {
            const response = await fetch('widget_data.json');
                
            if (response) {
                console.log("Data JSON fetch succeeded")
                return await response.json();}
        }

        function getQueryParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            console.log(urlParams.get(name));
            return urlParams.get(name);
        }

        let videoSource = {};

        async function createVideoScene(videoPair) {
            const scene = document.createElement('div');

            scene.innerHTML = `
            <div>
                <h2><Widget Image</h2>
                <img alt="design_screenshot sizes="print 73px,117px" src="${videoPair.screenshot_location}">
            </div>
            `;

            // Get widget description
            const description_prompt = videoPair.Description;
            document.getElementById("widget-content").textContent = description_prompt;

            // Get LLM reasoning
            const txt_location = videoPair.screenshot_location.replace(".png", ".txt");

            console.log("txt location", txt_location);
            
            fetch(txt_location)
                .then(response => response.text())
                .then(text => {
                    console.log("txt content", text);
                    document.getElementById("reasoning-context").textContent = text;
                })
                .catch(error => {
                    console.error("Error fetching text:", error);
                    document.getElementById("reasoning-context").textContent ="Fail to load text.";
                });
                

            const response = await fetch('https://relook.chenziwei0499.workers.dev/get', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ key: getQueryParameter('videoIndex') + getQueryParameter('user') })
            });


            let data = {};
            try {
            const text = await response.text();
            if (text.trim()) {
                data = JSON.parse(text);
            } else {
                console.warn('Empty response from /get endpoint');
                return scene; // Skip processing this entry
            }
            } catch (err) {
            console.error('Failed to parse JSON:', err);
            return scene;
            }

            const parsed = data; 

            console.log("parsed", data)
            console.log("parsed type", typeof data)
            const parsed_dict = data;

            // Get dark pattern type and explanation text
            const dark_pattern_type = parsed.value.dark_pattern_type

            if (!Array.isArray(dark_pattern_type) || dark_pattern_type.length === 0) {
                console.warn("Missing or empty dark_pattern_type:", parsed);
                return scene;
                }

            dark_pattern_type.forEach(value => {
                const checkboxes = container.querySelectorAll('input[type="checkbox"]');

                checkboxes.forEach(cb => {
                // Find the label linked to this checkbox
                const label = container.querySelector(`label[for="${cb.id}"]`);
                if (label && label.textContent.trim() === value) {
                    cb.checked = true;
                }
                });
            });

            return scene;
        }
        

        // Initialize by showing the scene based on the URL parameter
        window.addEventListener('DOMContentLoaded', init);

        function collectData() {

            // Collect data when users click buttons
            values = getSelectedCategories();

            const urlParams = new URLSearchParams(window.location.search);
            const videoIndex = urlParams.get('videoIndex');

            // Save deceptive design categories and explanation text
            const data = {
                dark_pattern_type: values
            }

            return data;
        }

        async function uploadData() {
            try {
                const data = collectData();

                if (!data) {
                    console.error("collectData returned null or undefined");
                    await Toast("Error: Failed to collect data", 3000);
                    return;
                }
                Toast('Uploading data...', 1000);

                let myuuid = crypto.randomUUID();
                const videoIndex = getQueryParameter('videoIndex');
                const user = getQueryParameter('user');

                if (!videoIndex || !user) {
                    console.error("Missing required parameters:", { videoIndex, user });
                    await Toast("Error: Missing videoIndex or user parameter", 3000);
                    return;
                }

                console.log("Uploading to /upload with:", {
                    key: myuuid,
                    index: videoIndex,
                    rater: user
                });

                
                const response = await fetch('https://relook.chenziwei0499.workers.dev/upload', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        key: myuuid,
                        index: widgetIndex,
                        rater: user
                    })
                });

                // Check if first request was successful
                if (!response.ok) {
                    console.error("Upload response error:", response.status, response.statusText);
                    const errorText = await response.text();
                    console.error("Upload error details:", errorText);
                    await Toast(`Upload failed: ${response.status} ${response.statusText}`, 3000);
                    return;
                }

                const uploadResult = await response.json();
                console.log("Upload response:", uploadResult);

                // Second request to /put with validation
                const putKey = videoIndex + user;
                const putPayload = {
                    key: putKey,
                    rater: user,
                    value: data
                };


                const response1 = await fetch('https://relook.chenziwei0499.workers.dev/put', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(putPayload)
                });

                // Check if second request was successful
                if (!response1.ok) {
                    console.error("Put response error:", response1.status, response1.statusText);
                    const errorText = await response1.text();
                    console.error("Put error details:", errorText);
                    await Toast(`Put request failed: ${response1.status} ${response1.statusText}`, 3000);
                    return;
                }

                const putResult = await response1.json();
                console.log("Put response:", putResult);
                await Toast("Data uploaded successfully!", 2000);

            } catch (error) {
            console.error("Upload function error:", error);
            await Toast(`Upload error: ${error.message}`, 3000);
            }
        }


        async function goToNextScene() {
            await uploadData();
            if (load_index < index_list.length - 1) {
                load_index += 1;
                await render();
                // Optional: update URL without reload
                const [widgetIndex] = index_list[load_index];
                const params = new URLSearchParams(location.search);
                params.set('user', user || '');
                params.set('videoIndex', widgetIndex);
                history.replaceState(null, '', `?${params.toString()}`);
            }
            }

        async function goToPrevScene() {
            await uploadData();
            if (load_index > 0) {
                load_index -= 1;
                await render();
                const [widgetIndex] = index_list[load_index];
                const params = new URLSearchParams(location.search);
                params.set('user', user || '');
                params.set('videoIndex', widgetIndex);
                history.replaceState(null, '', `?${params.toString()}`);
            }
        }


        async function Toast(msg, duration) {
            duration = isNaN(duration) ? 3000 : duration;
            var m = document.createElement('div');
            m.textContent = msg;
            m.style.cssText = "max-width:60%;min-width: 150px;padding:0 14px;height: 40px;color: rgb(255, 255, 255);line-height: 40px;text-align: center;border-radius: 4px;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);z-index: 999999;background: rgba(0, 0, 0,.7);font-size: 16px;";
            document.body.appendChild(m);
            setTimeout(function () {
                var d = 0.5;
                m.style.webkitTransition = '-webkit-transform ' + d + 's ease-in, opacity ' + d + 's ease-in';
                m.style.opacity = '0';
                setTimeout(function () { document.body.removeChild(m) }, d * 1000);
            }, duration);
            // wait for the toast to disappear
            await new Promise(r => setTimeout(r, duration));
        }


        document.getElementById('next-button').addEventListener('click', goToNextScene);
        document.getElementById('prev-button').addEventListener('click', goToPrevScene);
    </script>
</body>

</html>